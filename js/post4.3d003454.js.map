{"version":3,"sources":["webpack:///./src/pages/2017-10-07-restful-java.md"],"names":["module","exports","attributes","title","subtitle","date","tags","body","frontmatter"],"mappings":"0FAAAA,EAAAC,QAAA,CAAkBC,WAAA,CAAcC,MAAA,oBAAAC,SAAA,8DAAAC,KAAA,2BAAAC,KAAA,iBAA8JC,KAAA,0saAAkhaC,YAAA","file":"js/post4.3d003454.js","sourcesContent":["module.exports = {\"attributes\":{\"title\":\"RESTful API 的一个尝试\",\"subtitle\":\"设计一个 RESTful API，在 Java 的 Spring MVC 中实现它，最后在前端使用 ajax 验证它。\",\"date\":\"2017-10-07T05:07:00.000Z\",\"tags\":[\"Java\",\"REST\"]},\"body\":\"\\n### REST?\\n\\nREST（Representational State Transfer），表述性状态转移。\\n\\n`Representational` ：资源表述的形式。例如 JSON 和 XML 等。\\n\\n`State Transfer` ：资源状态转移。从一个应用转移到另一个应用。例如从服务器的 User 实体对象转移到终端的 JSON 资源。\\n\\n实现 REST 可以很好的分离前端和后端。尤其是有多套前端实现（Web、iOS、Android）的情况。让服务器只承担服务者的工作，展现形式交由前端发挥。\\n\\n### REST api 关注什么？\\n\\n关注下面三个点。\\n\\n- `URL` REST 使用 URL 对资源进行识别和定位。URL 表示需要什么。\\n- `Http method` REST 的行为通过 HTTP 方法（例如：GET、POST、DELETE、PUT）定义。方法表示做什么。\\n- `Status code` REST 用 HTTP 状态码告知结果。状态码表示结果。\\n\\n### Spring MVC 对 REST 的支持\\n\\n**Controller 可以处理所有 HTTP 方法**\\n\\n`@RequestMapping` 注解中的 method 可以指定所有 HTTP 方法。这使得我们可以指定针对什么方法的请求作出响应\\n\\n```java\\n@RequestMapping(value = \\\"/path\\\", method = RequestMethod.GET)\\n\\n// RequestMethod 如下\\npublic enum RequestMethod {\\n\\n\\tGET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE\\n\\n}\\n```\\n\\n**@ResponseBody 和 HttpMethodConverter 实现可以将对象作为资源发送给客户端**\\n\\n在类路径中加入 JSON 的依赖，HttpMethodConverter 或自动加载 JSON 解析器。\\n\\n```xml\\n<dependency>\\n  <groupId>com.fasterxml.jackson.core</groupId>\\n  <artifactId>jackson-core</artifactId>\\n  <version>2.9.1</version>\\n</dependency>\\n<dependency>\\n  <groupId>com.fasterxml.jackson.core</groupId>\\n  <artifactId>jackson-annotations</artifactId>\\n  <version>2.9.1</version>\\n</dependency>\\n<dependency>\\n  <groupId>com.fasterxml.jackson.core</groupId>\\n  <artifactId>jackson-databind</artifactId>\\n  <version>2.9.1</version>\\n</dependency>\\n```\\n\\n下面是处理请求并发送 JSON 格式资源给客户端的示例。\\n\\n```java\\n@RequestMapping(value = \\\"/target\\\",\\n    method = RequestMethod.GET,\\n    produces = \\\"application/json\\\")\\npublic @ResponseBody Target getTarget(@RequestParam(value = \\\"id\\\") int id) {\\n    // get the target object by id\\n    Target target = Respository.getTargetById(id);\\n    return target;\\n}\\n```\\n\\n这个方法可以处理路径为`host/target`的 GET 请求，并使用 produces 属性进一步限制只对接收 JSON 资源的请求进行响应。这个方法接收一个名为`id`的查询参数。返回类型前的`@ResponseBody`注解告诉消息转换器将返回的对象作为资源（这里是 JSON）发送给客户端。\\n\\n**@RequestBody 和 HttpMethodConverter 实现可以将客户端发来的资源转换为对象处理**\\n\\n以 JSON 为例，同样需求上面的 JSON 依赖。\\n\\n下面是接收客户端数据并作出响应的示例。\\n\\n```java\\n@RequestMapping(value = \\\"/target\\\",\\n    method = RequestMethod.POST,\\n    consumes = \\\"application/json\\\")\\npublic @ResponseBody Target addTarget(@RequestBody Target target){\\n    // save the target object\\n    Target target = Respository.addTarget(target);\\n    return Target;\\n}\\n```\\n\\n这个方法可以处理路径为`host/target`的 POST 请求，并使用 consumes 属性进一步限制只对数据为 JSON 格式的请求进行响应。参数前的`@RequestBody`注解可以告诉消息转换器将请求中的数据转换为 Target 对象。这里我们处理结束之后使用`@ResponseBody`注解将加工后的 target 对象作为资源再返回给客户端。\\n\\n针对上面提到的两种注解，`@ResponseBody`和`@RequestBody`，Spring MVC 还提供了 `@RestController` 注解来标记控制器类让其中的所有方法都应用信息转换功能。我们不必再手动添加`@ResponseBody`和`@RequestBody`注解了。\\n\\n所以上面的方法会变成下面这样。\\n\\n```java\\n@RestController\\npublic class TargetRestController {\\n\\n    @RequestMapping(value = \\\"/target\\\",\\n        method = RequestMethod.GET,\\n        produces = \\\"application/json\\\")\\n    public Target getTarget(@RequestParam(value = \\\"id\\\") int id) {\\n        // get the target object by id\\n        Target target = Respository.getTargetById(id);\\n        return target;\\n    }\\n\\n    @RequestMapping(value = \\\"/target\\\",\\n        method = RequestMethod.POST,\\n        consumes = \\\"application/json\\\")\\n    public Target addTarget(Target target){\\n        // save the target object\\n        Target target = Respository.addTarget(target);\\n        return Target;\\n    }\\n}\\n```\\n\\n怎么样，是不是清爽了很多？\\n\\n**返回 ResponseEntity 对象自定义响应**\\n\\n上面的配置已经能让我们接收数据和发送资源了。但是这还不够，考虑一下下面的情况。\\n\\n如果一切正常， getTarget() 方法会返回一个客户端预期的资源，同时响应中默认的 HTTP 状态码会是 200（OK）。这没什么问题，但是在 addTarget() 方法中，在成功保存了一个对象时，我们更希望响应中的状态码为 201 （CREATED），这样就显得更准确了。或者如果我们在保存对象或者查询对象的过程中出现了异常，这使得到的结果可能会是一个 null，由于我们没有做任何异常处理或者是错误检查（这个后面会提到），我们的控制器会返回一个 null 给客户端并且响应中的状态码依然是 200，这不太对。\\n\\n我们需要定制 Response，定义我们认为准确的状态码，这时候就要用到 ResponseEntity 对象了。\\n\\n下面这个控制器将完善 addTarget() 方法，它正常结束并且返回状态码 201。\\n\\n```java\\n@RestController\\npublic class TargetRestController {\\n\\n    @RequestMapping(value = \\\"/target\\\",\\n        method = RequestMethod.POST,\\n        consumes = \\\"application/json\\\")\\n    public ResponseEntity<Target> addTarget(Target target){\\n        // save the target object\\n        Target target = Respository.addTarget(target);\\n        return new ResponseEntity<Target>(target, HttpStatus.CREATED);\\n    }\\n}\\n```\\n\\n其实如果只是想自定义一个状态码，下面这个更为简洁。\\n\\n```java\\n@RestController\\npublic class TargetRestController {\\n\\n    @RequestMapping(value = \\\"/target\\\",\\n        method = RequestMethod.POST,\\n        consumes = \\\"application/json\\\")\\n    @ResponseStatus(HttpStatus.CREATED)\\n    public Target addTarget(Target target){\\n        // save the target object\\n        Target target = Respository.addTarget(target);\\n        return Target;\\n    }\\n}\\n```\\n\\n但是这并不意味着 ResponseEntity 没有意义。不，正相反，它的用处可大了。还是 addTarget() 方法，按照 REST 的思想，我们在保存了 target 对象之后最好再把访问这个对象的 URL 也一并发送给客户端，这样客户端就知道下一步怎么做了。那要怎么实现呢？\\n\\n我们可以把 URL 存到响应的 header 中。首先我们告诉 spring 把当前的地址通过参数的形式传递给我们，简单的添加一个接收参数并指定类型为 UriComponentBuilder，这样我们就可以获得当前的地址了。接下里一切都好办了，下面的控制器将访问保存之后的 target 的路径储存在了响应的 header 中以让客户端接收。\\n\\n```java\\n@RestController\\npublic class TargetRestController {\\n\\n    @RequestMapping(value = \\\"/target\\\",\\n        method = RequestMethod.POST,\\n        consumes = \\\"application/json\\\")\\n    public ResponseEntity<Target> addTarget(Target target, UriComponentBuilder ucb){\\n        // save the target object\\n        Target target = Respository.addTarget(target);\\n        HttpHeaders headers = new HttpHeaders();\\n        URI locationUri = ubc.path(\\\"/target\\\").queryParam(\\\"id\\\", target.getId()).build().toUri();\\n        headers.setLocation(locationUri);\\n        ResponseEntity<Target> responseEntity = new ResponseEntity<>(target, headers, HttpStatus.CREATED);\\n        return responseEntity;\\n    }\\n}\\n```\\n\\nUriComponentBuilder 的用法并不复杂，我们使用 `.path(\\\"URL\\\")` 方法将路径的后缀添加到根路径上，由于我们使用了查询参数来传递需要查询的 Target 的 id，所以使用 `.queryParam(\\\"key\\\", \\\"value\\\")` 方法把查询参数连接到地址上。\\n\\n这样客户端就可以从 header 中得到访问这个资源的地址了。\\n\\n嗯，到此我们简单的 REST api 差不多就完成了，具体怎么获得和保存对象不在本文的讨论范围内，如果你没有合适的环境测试，你也可以写个假的方法返回一个对象来进行下面的测试。\\n\\n哦，对了，在此之前还要说一下异常捕获和响应错误状态码。其实没有什么需要说的，和 spring MVC 下普通的异常处理一样。相信大家看看下面这个示例就了解了，这里就不多做解释了，注意返回类型即可。\\n\\n```java\\n@ExceptionHandler(targetException.class)\\npublic ResponseEntity<Error> error() {\\n    // do somethings with error object\\n    return new ResponseEntity<>(error,HttpStatus.NOT_FOUND);\\n}\\n@ExceptionHandler(targetNotFoundException.class)\\n@ResponseStatus(HttpStatus.NOT_FOUND)\\npublic @ResponseBody Error notFoundError() {\\n    // do somethings with error object\\n    return error;\\n}\\n```\\n\\n### 测试 REST api 的使用\\n\\nAPI 是实现好了，总归需要被使用。但是在这之前我们先看看 Target 类的内部。\\n\\n```java\\npublic class Target {\\n\\n\\n    private int id;\\n\\n    private String realName;\\n\\n    private String nickName;\\n\\n    private int age;\\n\\n    private String password;\\n\\n    // setter and getter\\n\\n}\\n```\\n\\n很简单的一个实体类，现在我们看看怎么使用 REST api 来获得资源。\\n\\n顺便一提，由于我同时也使用了 spring Security 框架，所以会包含一些 Security 相关的配置。\\n\\n**首先来看看如何获取 Target 资源**\\n\\n获取资源相对简单，因为 GET 方法在 Security 中不需要提供 CSRF token，我们可以简单的使用 ajax 来请求资源。\\n\\n假设我们需要在下面这个路径请求资源，而这个路径默认显示主页。（假设它就是显示主页）\\n\\n> https://10.0.0.26:8443/\\n\\n我们将使用到 JQuery 去发送 ajax 请求。（因为方便呀！）\\n\\n所以把 JQuery 的依赖写进 HTML 中去。（或者 JSP，保证上面的路径下面访问的页面加载了 JQuery 即可）\\n\\n本地引用或者在线引用都行，也可以使用下面的 CDN。\\n\\n```html\\n<script src=\\\"https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js\\\"></script>\\n```\\n\\nOK，一切就绪，我们现在已经到了根路径下，这个路径映射到了我们网站的主页，主页又加载了 JQuery，所以我们可以使用下面的 js 来请求资源了。\\n\\n```javascript\\n$.ajax({\\n  url: 'target?id=10013',\\n  type: 'GET',\\n  dataType: 'json',\\n  success: function(result) {\\n    $('body').html(JSON.stringify(result))\\n  },\\n})\\n```\\n\\n我们使用相对路径向 target 发出了 GET 请求，实际上接收到请求的路径应该是下面这样。\\n\\n> https://10.0.0.26:8443/target\\n\\n我们的请求还有一个查询参数，告诉服务器我们要查找 id 为 10013 的 target 资源。`dataType`属性告诉服务器我们接收 JSON 格式的资源。这符合我们的 api 规范，很好，服务器响应了，并且将需要的资源发送给了我们。我在 ajax 的回调函数里面把服务器响应的资源写到了 body 上，所以我们可以看到画面上显示了下面的信息。\\n\\n```json\\n{\\n  \\\"id\\\": 10013,\\n  \\\"realName\\\": null,\\n  \\\"nickName\\\": \\\"nan\\\",\\n  \\\"age\\\": 31,\\n  \\\"password\\\": \\\"asd24698\\\"\\n}\\n```\\n\\n很好，成功了，数据和我们数据库的一致。我们再来看看请求和响应的信息。\\n\\nRequest header:\\n\\n```http\\nGET /target?id=10013 HTTP/1.1\\nHost: 10.0.0.26:8443\\nConnection: keep-alive\\nAccept: application/json, text/javascript, */*; q=0.01\\nX-Requested-With: XMLHttpRequest\\nUser-Agent: (too long so let's omit it)\\nReferer: https://10.0.0.26:8443/\\nAccept-Encoding: gzip, deflate, br\\nAccept-Language: zh-CN,zh;q=0.8\\nCookie: (too long so let's omit it)\\n```\\n\\nResponse header:\\n\\n```http\\nHTTP/1.1 200\\nX-Content-Type-Options: nosniff\\nX-XSS-Protection: 1; mode=block\\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\\nPragma: no-cache\\nExpires: 0\\nStrict-Transport-Security: max-age=31536000 ; includeSubDomains\\nX-Frame-Options: DENY\\nContent-Type: application/json;charset=UTF-8\\nTransfer-Encoding: chunked\\nDate: Sun, 08 Oct 2017 15:55:34 GMT\\n```\\n\\n可以看到请求中我们声明接收 JSON 格式的资源，响应中确实给了我们预期的资源。状态码也 OK，一切都很正常。下面我们先看看异常处理时的结果如何。\\n\\n下面同样的请求，我们事先将 id 为 10013 的 target 删除，这样这个请求就必定会抛出一个异常告诉服务器找不到资源。注意下面的回调函数，上面的示例请求成功所以我们使用 success 来定义资源请求成功后该做什么，但是下面的请求必将失败，我们换用 error 来定义请求失败后做什么。这里我们还是将相应的内容输出在 body 上。\\n\\n```javascript\\n$.ajax({\\n  url: 'target?id=10013',\\n  type: 'GET',\\n  dataType: 'json',\\n  error: function(xhr) {\\n    $('body').html(xhr.responseText)\\n  },\\n})\\n```\\n\\n执行代码，我们得到了下面的结果。\\n\\n```json\\n{ \\\"message\\\": \\\"Not Found.\\\", \\\"id\\\": 5 }\\n```\\n\\n这和我定义的错误信息一致。我们继续看一下 header 信息。\\n\\nRequest header:\\n\\n```http\\nGET /target?id=10013 HTTP/1.1\\nHost: 10.0.0.26:8443\\nConnection: keep-alive\\nAccept: application/json, text/javascript, */*; q=0.01\\nX-Requested-With: XMLHttpRequest\\nUser-Agent: (too long so let's omit it)\\nReferer: https://10.0.0.26:8443/\\nAccept-Encoding: gzip, deflate, br\\nAccept-Language: zh-CN,zh;q=0.8\\nCookie: (too long so let's omit it)\\n```\\n\\nResponse header:\\n\\n```http\\nHTTP/1.1 404\\nX-Content-Type-Options: nosniff\\nX-XSS-Protection: 1; mode=block\\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\\nPragma: no-cache\\nExpires: 0\\nStrict-Transport-Security: max-age=31536000 ; includeSubDomains\\nX-Frame-Options: DENY\\nContent-Type: application/json;charset=UTF-8\\nTransfer-Encoding: chunked\\nDate: Sun, 08 Oct 2017 15:57:36 GMT\\n```\\n\\n我们定义的状态码 404 也起作用了。我们的第一个 api 成功了。接下来我们看看第二个。\\n\\n**保存并获取 Target 资源**\\n\\n在第二个 api 中我们保存一个 Target 对象到数据库中，并且将保存后的对象返回给客户端，同时我们还将访问这个资源的 URI 也写进了响应的 header 中，让我们来看看怎么使用这个 api。\\n\\n如果仅仅在上面的方法上稍作修改就去使用的话，我们会得到 403 错误。这是因为我们同时使用了 Security 框架，并且对 POST 请求要求验证通过 CSRF token，否则服务器将拒绝我们的请求。那么问题来了，CSRF token 从哪儿获得呢？\\n\\n如果你使用的是 JSP 页面的话，这一点很容易做到，简单的在表单中添加下面的 hidden 项目，我们将自动获得 CSRF token。\\n\\n```html\\n<input type=\\\"hidden\\\" name=\\\"${_csrf.parameterName}\\\" value=\\\"${_csrf.token}\\\" />\\n```\\n\\n我们可能要将 token 放在 header 中，可能我们还需要 key 的名称。在 HTML 的`<head>`标签内加入下面的标签可以让我们获得想要的信息。\\n\\n```html\\n<html>\\n  <head>\\n    <meta name=\\\"_csrf\\\" content=\\\"${_csrf.token}\\\" />\\n    <!-- default header name is X-CSRF-TOKEN -->\\n    <meta name=\\\"_csrf_header\\\" content=\\\"${_csrf.headerName}\\\" />\\n    <!-- ... -->\\n  </head>\\n  <!-- ... -->\\n</html>\\n```\\n\\n但是我们要将前端和后端分离的话，使用 JSP 不太现实，或许我们希望使用纯 HTML 页面来制作我们的前端。这时我们可以让 Security 将 token 写到 cookie 中去。这需要下面这些设置。\\n\\n```java\\n@Configuration\\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\\n\\n    @Override\\n    protected void configure(HttpSecurity http) throws Exception {\\n        http\\n            // settings\\n            .and()\\n            .csrf().csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());\\n    }\\n}\\n```\\n\\n`CookieCsrfTokenRepository.withHttpOnlyFalse()` 告诉 Security 框架将 token 写入 cookie 中，并且允许我们使用 js 获取。\\n\\n现在万事俱备，我们可以使用下面的 js 尝试保存一个 target 了。\\n\\n```javascript\\n$.ajax({\\n  url: 'api/spitter',\\n  beforeSend: function(request) {\\n    var match = window.document.cookie.match(\\n      /(?:^|\\\\s|;)XSRF-TOKEN\\\\s*=\\\\s*([^;]+)(?:;|$)/\\n    )\\n    request.setRequestHeader('X-XSRF-TOKEN', match && match[1])\\n  },\\n  type: 'POST',\\n  contentType: 'application/json',\\n  data: JSON.stringify({\\n    id: 1234,\\n    realName: null,\\n    nickName: 'API_USER_TEST',\\n    age: 99,\\n    password: 'THIS_IS_CREATE_BY_API_TEST',\\n  }),\\n  success: function(result) {\\n    $('body').html(JSON.stringify(result))\\n  },\\n})\\n```\\n\\n这里我们定义 beforeSend 使其在请求发送之前将 token 装入 header 中。我们使用正则表达式从 cookies 中匹配出 token。我们用 contentType 属性告诉服务器我们发送的数据的格式。这里有一点要注意，发送的 JSON 格式数据要求严格格式，我们需要使用`JSON.stringify()`方法格式化一下我们的 JSON 对象，否则将出现错误。和之前一样，如果成功我们将结果写入 body 来验证。我们看到了下面的结果。\\n\\n```json\\n{\\n  \\\"id\\\": 10014,\\n  \\\"realName\\\": null,\\n  \\\"nickName\\\": \\\"API_USER_TEST\\\",\\n  \\\"age\\\": 99,\\n  \\\"password\\\": \\\"THIS_IS_CREATE_BY_API_TEST\\\"\\n}\\n```\\n\\n我们成功了，再看一下 header 信息。\\n\\nRequest header:\\n\\n```http\\nPOST /target HTTP/1.1\\nHost: 10.0.0.26:8443\\nConnection: keep-alive\\nContent-Length: 103\\nOrigin: https://10.0.0.26:8443\\nX-XSRF-TOKEN: 2d19f598-78dd-448e-809c-9a75cc987ab7\\nUser-Agent: (too long so let's omit it)\\nContent-Type: application/json\\nAccept: */*\\nX-Requested-With: XMLHttpRequest\\nReferer: https://10.0.0.26:8443/\\nAccept-Encoding: gzip, deflate, br\\nAccept-Language: zh-CN,zh;q=0.8\\nCookie: (too long so let's omit it)\\n```\\n\\nResponse header:\\n\\n```http\\nHTTP/1.1 201\\nX-Content-Type-Options: nosniff\\nX-XSS-Protection: 1; mode=block\\nCache-Control: no-cache, no-store, max-age=0, must-revalidate\\nPragma: no-cache\\nExpires: 0\\nStrict-Transport-Security: max-age=31536000 ; includeSubDomains\\nX-Frame-Options: DENY\\nLocation: https://10.0.0.26:8443/target?id=10014\\nContent-Type: application/json;charset=UTF-8\\nTransfer-Encoding: chunked\\nDate: Sun, 08 Oct 2017 16:33:33 GMT\\n```\\n\\n请求的 header 中我们将 X-XSRF-TOKEN 放了进去，所以我们顺利通过了验证。服务器处理了我们的请求，并且将处理后的对象发给了我们。（id 是保存后取出来的）\\n\\n在响应中我们得到了更合理的 201 状态码，同时 Location 属性告诉了我们下一步应该怎么做。\\n\",\"frontmatter\":\"title: RESTful API 的一个尝试\\nsubtitle: 设计一个 RESTful API，在 Java 的 Spring MVC 中实现它，最后在前端使用 ajax 验证它。\\ndate: 2017-10-7 13:07:00 +8\\ntags:\\n  - Java\\n  - REST\"}"],"sourceRoot":""}