{"version":3,"sources":["webpack:///./src/pages/2017-09-10-memo-spring-mvc.md"],"names":["module","exports","attributes","title","subtitle","date","tags","body","frontmatter"],"mappings":"wFAAAA,EAAAC,QAAA,CAAkBC,WAAA,CAAcC,MAAA,oBAAAC,SAAA,iCAAAC,KAAA,2BAAAC,KAAA,mBAAmIC,KAAA,myQAA23QC,YAAA","file":"js/post0.101fd4f7.js","sourcesContent":["module.exports = {\"attributes\":{\"title\":\"关于 Spring 框架的一些笔记\",\"subtitle\":\"学习 Spring MVC，DI，AOP 等相关知识的笔记。\",\"date\":\"2017-09-10T00:03:51.000Z\",\"tags\":[\"Java\",\"Spring\"]},\"body\":\"\\n最近阅读《Spring in Action》一书来学习和练习 spring 框架的使用。对学习中遇到对一些问题以及解决对方法做一些笔记。\\n\\n---\\n\\n### Spring MVC 配置\\n\\n**Spring MCV 基本配置**\\n\\n基于 Java 的配置：\\n\\n```java\\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\\n\\npublic class SpittrWebApplicationInitializer extends\\n    AbstractAnnotationConfigDispatcherServletInitializer {\\n\\n    @Override\\n    protected Class<?>[] getRootConfigClasses() {\\n        return new Class<?>[] {RootConfig.class};\\n    }\\n\\n    @Override\\n    protected Class<?>[] getServletConfigClasses() {\\n        return new Class<?>[] {WebConfig.class};\\n    }\\n\\n    @Override\\n    protected String[] getServletMappings() {\\n        return new String[] {\\\"/\\\"};\\n    }\\n\\n}\\n```\\n\\n对于`RootConfig.java`暂时留空：\\n\\n```java\\nimport org.springframework.context.annotation.ComponentScan;\\nimport org.springframework.context.annotation.ComponentScan.Filter;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.context.annotation.FilterType;\\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\\n\\n@Configuration\\n@ComponentScan(basePackages={\\\"springtest\\\"},\\n        excludeFilters={@Filter(type=FilterType.ANNOTATION,value=EnableWebMvc.class)})\\npublic class RootConfig {\\n\\n}\\n```\\n\\n对于`WebConfig.java`需要配置 ViewResolver：\\n\\n```java\\nimport org.springframework.context.annotation.Bean;\\nimport org.springframework.context.annotation.ComponentScan;\\nimport org.springframework.context.annotation.Configuration;\\nimport org.springframework.context.annotation.EnableAspectJAutoProxy;\\nimport org.springframework.web.servlet.ViewResolver;\\nimport org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\\nimport org.springframework.web.servlet.view.InternalResourceViewResolver;\\n\\n\\n@Configuration\\n@EnableWebMvc\\n@EnableAspectJAutoProxy\\n@ComponentScan({\\\"springtest\\\"})\\npublic class WebConfig extends WebMvcConfigurerAdapter {\\n    @Bean\\n    public ViewResolver verwResolver() {\\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\\n        resolver.setPrefix(\\\"/WEB-INF/view/\\\");\\n        resolver.setSuffix(\\\".jsp\\\");\\n        resolver.setExposeContextBeansAsAttributes(true);\\n        return resolver;\\n    }\\n\\n    @Override\\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\\n        super.configureDefaultServletHandling(configurer);\\n        configurer.enable();\\n    }\\n}\\n```\\n\\n基于 web.xml 的配置：\\n\\n```xml\\n<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n<web-app version=\\\"2.5\\\"\\n    xmlns=\\\"http://java.sun.com/xml/ns/javaee\\\"\\n    xmlns:xsi=\\\"http://www.w3.org/2001/XMLSchema-instance\\\"\\n    xsi:schemaLocation=\\\"http://java.sun.com/xml/ns/javaee\\n        http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\\\">\\n    <context-param>\\n        <param-name>contextConfigLocation</param-name>\\n        <param-value>/WEB-INF/spring/root-context.xml</param-value>\\n    </context-param>\\n    <listener>\\n        <listener-class>\\n            org.springframework.web.context.ContextLoaderListener\\n        </listener-class>\\n    </listener>\\n    <servlet>\\n        <servlet-name>appServlet</servlet-name>\\n        <servlet-class>\\n            org.springframework.web.servlet.DispatcherServlet\\n        </servlet-class>\\n        <load-on-startup>1</load-on-startup>\\n    </servlet>\\n    <servlet-mapping>\\n        <servlet-name>appServlet</servlet-name>\\n        <url-pattern>/</url-pattern>\\n    </servlet-mapping>\\n</web-app>\\n\\n```\\n\\n**ViewResolver 配置**\\n\\n常用的视图解析器为`InternalResourceViewResolver`和`ResourceBundleViewResolver`，下面记录对前者的一些配置。\\n\\n基于 Java 的最简单配置：\\n\\n```java\\n    @Bean\\n    public ViewResolver verwResolver() {\\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\\n        // 设置前缀\\n        resolver.setPrefix(\\\"/WEB-INF/view/\\\");\\n        // 设置后缀\\n        resolver.setSuffix(\\\".jsp\\\");\\n        return resolver;\\n    }\\n```\\n\\n基于 XML 的最简单配置：\\n\\n```xml\\n<bean id=\\\"viewResolver\\\"\\n    class=\\\"org.springframework.web.servlet.view.InternalResourceViewResolver\\\"\\n    p:prefix=\\\"/WEB-INF/view/\\\"\\n    p:suffix=\\\".jsp\\\" />\\n```\\n\\n`InternalResourceViewResolver`默认将逻辑视图解析为`InternalResourceView`对象。对于使用了 JSTL 标签来处理格式化和信息的 JSP 页面，它需要一个 `Locale` 对象来正确的格式化日期和货币等地域化的值，这时需要让解析器将视图解析为`JstlView`。简单的修改解析器的`ViewClass`属性。\\n\\n基于 Java：\\n\\n```java\\n    @Bean\\n    public ViewResolver verwResolver() {\\n        InternalResourceViewResolver resolver = new InternalResourceViewResolver();\\n        ...\\n        relover.setViewClass(org.springframework.web.servlet.view.JstlView.class);\\n        ...\\n        return resolver;\\n    }\\n```\\n\\n基于 XML:\\n\\n```xml\\n<bean id=\\\"viewResolver\\\"\\n    class=\\\"org.springframework.web.servlet.view.InternalResourceViewResolver\\\"\\n    p:prefix=\\\"/WEB-INF/view/\\\"\\n    p:suffix=\\\".jsp\\\"\\n    p:viewClass=\\\"org.springframework.web.servlet.view.JstlView\\\" />\\n```\\n\\n### Spring MVC 参数传递\\n\\n**向页面传参**\\n\\n给 Controller 一个 Model 型或者 Map 型的参数。将需要给页面传的参数以键值对的形式放入这个 model 中，让页面（View 层）接收。\\n\\n```java\\n    @RequestMapping(value=\\\"/spittle\\\")\\n    public String toSpittle(Model model) {\\n        model.addAttribute(\\\"spittle\\\", (Spittle object));\\n        return \\\"spittle\\\";\\n    }\\n```\\n\\n**URL 查询参数**\\n\\n适用于 URL 地址+`?para=value&morePara=value...`的查询参数。用`@RequestParam`注解获取 URL 地址查询参数，需要设定获得的`value`名，`defaultValue`是可选项，在没有这个 value 值时默认赋值。\\n\\n```java\\n    @RequestMapping(value=\\\"/id\\\")\\n    public String toSpittleInId(\\n            @RequestParam(value=\\\"id\\\", defaultValue=\\\"1\\\") Long id,\\n            Model model) {\\n        ...\\n        model.addAttribute(\\\"spittle\\\", spittleRepository.findSpittle(id));\\n        return \\\"spittle\\\";\\n    }\\n```\\n\\n**URL 路径参数**\\n\\n使用指定的 URL 路径作为参数。适用于 URL 为`basePath/param`的形式。需要以`/id{id}`的形式在映射的地址上用花括号（{}）定义一个参数名，用`@PathVariable`注解接收这个参数（接收的参数名必须和花括号定义的一致）。\\n\\n```java\\n    @RequestMapping(value=\\\"/id{id}\\\")\\n    public String toSpittleInId(\\n            @PathVariable Long id,\\n            Model model) {\\n        ...\\n        model.addAttribute(\\\"spittle\\\", spittleRepository.findSpittle(id));\\n        return \\\"spittle\\\";\\n    }\\n```\\n\\n**实体类**\\n\\n在说到表单映射之前要先提到实体类。实体类是为了映射数据库对象以及页面表单对象而存在的类，它需要符合下面的规范。\\n\\n- 显式的无参构造器（no-argument constructor）\\n- private 修饰符的属性（private fields）\\n- Setter/Getter 方法（Setter/Getter accessor）\\n\\n**表单映射**\\n\\n给 Controller 传递一个实体类参数，页面上的表单内 name 值与实体类属性名相同的字段将自动装配到实体类。\\n\\nController with an entity object argument\\n\\n```java\\n    @RequestMapping(value = \\\"/register\\\", method = RequestMethod.POST)\\n    public String registration(Spitter spitter) {\\n        ...\\n        return \\\"redirect:/spitter/\\\" + spitter.getNickName();\\n    }\\n```\\n\\nEntity object has private fields and Setter/Getter/no-argument constructor\\n\\n```java\\npublic class Spitter {\\n\\n    private String realName;\\n    private String nickName;\\n    private String username;\\n    private String password;\\n    ...\\n    (Setter/Getter and explicit no-argument constructor)\\n    ...\\n}\\n```\\n\\nThe form's fields have same name with the entity object\\n\\n```html\\n<form action=\\\"\\\" method=\\\"post\\\">\\n  Real Name: <input name=\\\"realName\\\" /> <br />\\n  Nick Name: <input name=\\\"nickName\\\" /> <br />\\n  Username: <input name=\\\"username\\\" /> <br />\\n  Password: <input name=\\\"password\\\" type=\\\"password\\\" /> <br />\\n  <input type=\\\"submit\\\" value=\\\"Register\\\" />\\n</form>\\n```\\n\\n### Spring MVC 控制器与异常处理\\n\\n**控制器**\\n\\n加了`@Controller`注解的类即控制器。用`@RequestMapping`注解定义映射的路径。\\n\\n**异常处理**\\n\\n使用`@ControllerAdvice`注解定义控制器通知类，使用`@ExceptionHandler`注解定义需要处理的异常和处理方法体。\\n\\n```java\\nimport org.springframework.http.HttpStatus;\\nimport org.springframework.web.bind.annotation.ControllerAdvice;\\nimport org.springframework.web.bind.annotation.ExceptionHandler;\\nimport org.springframework.web.bind.annotation.ResponseStatus;\\nimport org.springframework.web.servlet.NoHandlerFoundException;\\nimport springtest.exception.SpitterNotFoundException;\\n\\n@ControllerAdvice\\npublic class AppWideExceptionHandler {\\n\\n    @ExceptionHandler(value = { SpitterNotFoundException.class, NoHandlerFoundException.class })\\n    @ResponseStatus(HttpStatus.NOT_FOUND)\\n    public String spitterNotFoundHandler() {\\n        return \\\"error/404\\\";\\n    }\\n}\\n```\\n\\n但是在处理 404 时遇到一个问题，如果在`WebConfig.java`中开启了默认处理的话，404 会被默认的 Handler 处理，我使用的是 Tomcat 容器，开启默认处理之后 404 会被 Tomcat 处理跳转到服务器的 404 报告页面。这时需要移除下面这行关闭默认的处理。\\n\\n```java\\n    configurer.enable();\\n```\\n\",\"frontmatter\":\"title: 关于 Spring 框架的一些笔记\\nsubtitle: 学习 Spring MVC，DI，AOP 等相关知识的笔记。\\ndate: 2017-9-10 08:03:51 +8\\ntags:\\n  - Java\\n  - Spring\"}"],"sourceRoot":""}